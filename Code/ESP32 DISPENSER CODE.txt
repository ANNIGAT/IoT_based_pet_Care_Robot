ESP32 DISPENSER CODE 
#include <Arduino.h> 
https://github.com/bblanchon/ArduinoJson 
#include <WiFi.h>
#include "SinricPro.h" 
ricpro.github.io/esp8266-esp32-sdk/ 
#include "SinricProSwitch.h" 
#include <map> 
#ifdef ENABLE_DEBUG 
#define DEBUG_ESP_PORT Serial 
#define NODEBUG_WEBSOCKETS 
https://github.com/Links2004/arduinoWebSockets 
#define NDEBUG 
#endif 
#define WIFI_SSID 
#define WIFI_PASS 
#define APP_KEY 
"Badri" 
"Badri235"  
//SinricPro Library: https://sin- 
//arduinoWebSockets Library: 
//Enter WiFi Name 
//Enter WiFi Password 
"d0d5cf64-06f6-493a-b570-0b4c96f5fac8" 
ter APP-KEY 
#define APP_SECRET  
//En- 
"b229069b-066-46b2-8ebe-644877f53200-c37ddb22-5ec9- 
47c2-8980-28227457a0e3" 
//Enter the device IDs here 
//Enter APP-SECRET 
#define device_ID_1 "644e32bc32d40edc3ff636c" //SWITCH 1 ID 
#define device_ID_2 "644e330312d40edc3ff63cf" //SWITCH 2 ID 
// define the GPIO connected with Relays and switches 
#define RelayPin1 23 //D23 
#define RelayPin2 22 //D22 
#define SwitchPin1 13 //D13 
#define SwitchPin2 12 //D12 
#define wifiLed 2 //D2 
#define BAUD_RATE 9600 
#define DEBOUNCE_TIME 250 
typedef struct { 
int relayPIN; 
// struct for the std::map below 
59
int flipSwitchPIN; 
} deviceConfig_t; 
std::map<String, deviceConfig_t> devices = { 
//{deviceId, {relayPIN, flipSwitchPIN}} 
{device_ID_1, {  RelayPin1, SwitchPin1 }}, 
{device_ID_2, { RelayPin2, SwitchPin2 }} 
}; 
typedef struct { 
String deviceId; 
// struct for the std::map below 
bool lastFlipSwitchState; 
unsigned long lastFlipSwitchChange; 
} flipSwitchConfig_t; 
std::map<int, flipSwitchConfig_t> flipSwitches; 
// this map is used to map 
flipSwitch PINs to deviceId and handling debounce and last flipSwitch state checks 
// it will be setup in 
"setupFlipSwitches" function, using informations from devices map 
void setupRelays() { 
for (auto &device : devices) { 
combination) 
// for each device (relay, flipSwitch 
int relayPIN = device.second.relayPIN; // get the relay pin 
pinMode(relayPIN, OUTPUT); 
// set relay pin to OUTPUT 
digitalWrite(relayPIN, HIGH); 
} 
} 
void setupFlipSwitches() { 
for (auto &device : devices) { 
/ flipSwitch combination) 
flipSwitchConfig_t flipSwitchConfig; 
configuration 
flipSwitchConfig.deviceId = device.first; 
flipSwitchConfig.lastFlipSwitchChange = 0; 
flipSwitchConfig.lastFlipSwitchState = false; 
to false (LOW)-- 
// for each device (relay 
// create a new flipSwitch 
// set the deviceId 
// set debounce time 
// set lastFlipSwitchState
int flipSwitchPIN = device.second.flipSwitchPIN; // get the flipSwitchPIN 
flipSwitches[flipSwitchPIN] = flipSwitchConfig; 
config to flipSwitches map 
pinMode(flipSwitchPIN, INPUT_PULLUP); 
pin to INPUT 
} 
} 
bool onPowerState(String deviceId, bool &state) 
{ 
// save the flipSwitch 
// set the flipSwitch 
Serial.printf("%s: %s\r\n", deviceId.c_str(), state ? "on" : "off"); 
int relayPIN = devices[deviceId].relayPIN; // get the relay pin for corresponding 
device 
digitalWrite(relayPIN, state); 
return true; 
} 
void handleFlipSwitches() { 
unsigned long actualMillis = millis(); 
get actual millis 
for (auto &flipSwitch : flipSwitches) { 
for each flipSwitch in flipSwitches map 
// set the new relay state 
// 
// 
unsigned long lastFlipSwitchChange = flipSwitch.second.lastFlipSwitch- 
Change; // get the timestamp when flipSwitch was pressed last time (used to 
debounce / limit events) 
if (actualMillis - lastFlipSwitchChange > DEBOUNCE_TIME) { 
if time is > debounce time... 
int flipSwitchPIN = flipSwitch.first; 
get the flipSwitch pin from configuration 
bool lastFlipSwitchState = flipSwitch.second.lastFlipSwitchState; 
get the lastFlipSwitchState 
bool flipSwitchState = digitalRead(flipSwitchPIN); 
read the current flipSwitch state 
if (flipSwitchState != lastFlipSwitchState) { 
if the flipSwitchState has changed... 
#ifdef TACTILE_BUTTON 
if (flipSwitchState) { 
if the tactile button is pressed 
#endif 
// 
// 
// 
// 
// 
//
flipSwitch.second.lastFlipSwitchChange = actualMillis; 
update lastFlipSwitchChange time 
String deviceId = flipSwitch.second.deviceId; 
get the deviceId from config 
int relayPIN = devices[deviceId].relayPIN; 
get the relayPIN from config 
bool newRelayState = !digitalRead(relayPIN); 
set the new relay State 
digitalWrite(relayPIN, newRelayState); 
set the trelay to the new state 
SinricProSwitch &mySwitch = SinricPro[deviceId]; 
get Switch device from SinricPro 
mySwitch.sendPowerStateEvent(!newRelayState); 
send the event 
#ifdef TACTILE_BUTTON 
} 
#endif 
flipSwitch.second.lastFlipSwitchState = flipSwitchState; 
update lastFlipSwitchState 
} 
} 
} 
} 
void setupWiFi() 
{ 
Serial.printf("\r\n[Wifi]: Connecting"); 
WiFi.begin(WIFI_SSID, WIFI_PASS); 
while (WiFi.status() != WL_CONNECTED) 
{ 
Serial.printf("."); 
delay(250); 
} 
digitalWrite(wifiLed, HIGH); 
// 
// 
// 
// 
// 
// 
// 
// 
Serial.printf("connected!\r\n[WiFi]: IP-Address is %s\r\n", WiFi.lo- 
calIP().toString().c_str()); 
} 
void setupSinricPro() 
{ 
for (auto &device : devices) 
{ 
const char *deviceId = device.first.c_str(); 
SinricProSwitch &mySwitch = SinricPro[deviceId]; 
mySwitch.onPowerState(onPowerState); 
} 
SinricPro.begin(APP_KEY, APP_SECRET); 
SinricPro.restoreDeviceStates(true); 
} 
void setup() 
{ 
Serial.begin(BAUD_RATE); 
pinMode(wifiLed, OUTPUT); 
digitalWrite(wifiLed, LOW); 
setupRelays(); 
setupFlipSwitches(); 
setupWiFi(); 
setupSinricPro(); 
} 
void loop() 
{ 
SinricPro.handle(); 
handleFlipSwitches(); 
}